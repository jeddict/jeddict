//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.10 in JDK 6
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
// Any modifications to this file will be lost upon recompilation of the source schema.
// Generated on: 2014.01.21 at 01:52:19 PM IST
//
package io.github.jeddict.jpa.spec;

import io.github.jeddict.jcode.jpa.PersistenceProviderType;
import io.github.jeddict.jcode.util.JavaSourceHelper;
import static io.github.jeddict.jcode.util.JavaUtil.mergePackage;
import io.github.jeddict.jpa.spec.bean.BeanClass;
import io.github.jeddict.jpa.spec.design.Diagram;
import io.github.jeddict.jpa.spec.extend.Attribute;
import io.github.jeddict.jpa.spec.extend.BaseElement;
import io.github.jeddict.jpa.spec.extend.IPersistenceAttributes;
import io.github.jeddict.jpa.spec.extend.JavaClass;
import io.github.jeddict.jpa.spec.extend.MapKeyHandler;
import io.github.jeddict.jpa.spec.extend.MapKeyType;
import io.github.jeddict.jpa.spec.extend.MultiRelationAttribute;
import io.github.jeddict.jpa.spec.extend.PersistenceAttributes;
import io.github.jeddict.jpa.spec.extend.ProjectType;
import io.github.jeddict.jpa.spec.extend.ReferenceClass;
import io.github.jeddict.jpa.spec.extend.RelationAttribute;
import io.github.jeddict.jpa.spec.extend.cache.Cache;
import io.github.jeddict.jpa.spec.workspace.WorkSpace;
import io.github.jeddict.jpa.spec.workspace.WorkSpaceItem;
import io.github.jeddict.jsonb.spec.JsonbDateFormat;
import io.github.jeddict.jsonb.spec.JsonbNumberFormat;
import io.github.jeddict.jsonb.spec.JsonbVisibilityHandler;
import io.github.jeddict.jsonb.spec.PropertyNamingStrategy;
import io.github.jeddict.jsonb.spec.PropertyOrderStrategy;
import io.github.jeddict.snippet.ClassSnippet;
import io.github.jeddict.snippet.ClassSnippetLocationType;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.CopyOnWriteArrayList;
import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toSet;
import java.util.stream.Stream;
import javax.xml.bind.Unmarshaller;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElementWrapper;
import javax.xml.bind.annotation.XmlIDREF;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.XmlType;
import io.github.jeddict.util.StringUtils;
import static io.github.jeddict.util.StringUtils.isBlank;
import static io.github.jeddict.util.StringUtils.isEmpty;
import static io.github.jeddict.util.StringUtils.isNotBlank;
import org.netbeans.modeler.core.NBModelerUtil;
import org.netbeans.modeler.core.exception.InvalidElmentException;
import org.netbeans.modeler.specification.model.document.IDefinitionElement;
import org.netbeans.modeler.specification.model.document.IRootElement;
import org.netbeans.modeler.specification.model.document.core.IBaseElement;
import org.netbeans.modeler.specification.version.SoftwareVersion;
import org.openide.windows.InputOutput;

/**
 *
 *
 * The entity-mappings element is the root element of a mapping file. It
 * contains the following four types of elements:
 *
 * 1. The persistence-unit-metadata element contains metadata for the entire
 * persistence unit. It is undefined if this element occurs in multiple mapping
 * files within the same persistence unit.
 *
 * 2. The package, schema, catalog and access elements apply to all of the
 * entity, mapped-superclass and embeddable elements defined in the same file in
 * which they occur.
 *
 * 3. The sequence-generator, table-generator, converter, named-query,
 * named-native-query, named-stored-procedure-query, and sql-result-set-mapping
 * elements are global to the persistence unit. It is undefined to have more
 * than one sequence-generator or table-generator of the same name in the same
 * or different mapping files in a persistence unit. It is undefined to have
 * more than one named-query, named-native-query, sql-result-set-mapping, or
 * named-stored-procedure-query of the same name in the same or different
 * mapping files in a persistence unit. It is also undefined to have more than
 * one converter for the same target type in the same or different mapping files
 * in a persistence unit.
 *
 * 4. The entity, mapped-superclass and embeddable elements each define the
 * mapping information for a managed persistent class. The mapping information
 * contained in these elements may be complete or it may be partial.
 *
 *
 *
 * <p>
 * Java class for anonymous complex type.
 *
 * <p>
 * The following schema fragment specifies the expected content contained within
 * this class.
 *
 * <pre>
 * &lt;complexType>
 *   &lt;complexContent>
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       &lt;sequence>
 *         &lt;element name="description" type="{http://www.w3.org/2001/XMLSchema}string" minOccurs="0"/>
 *         &lt;element name="persistence-unit-metadata" type="{http://java.sun.com/xml/ns/persistence/orm}persistence-unit-metadata" minOccurs="0"/>
 *         &lt;element name="package" type="{http://www.w3.org/2001/XMLSchema}string" minOccurs="0"/>
 *         &lt;element name="schema" type="{http://www.w3.org/2001/XMLSchema}string" minOccurs="0"/>
 *         &lt;element name="catalog" type="{http://www.w3.org/2001/XMLSchema}string" minOccurs="0"/>
 *         &lt;element name="access" type="{http://xmlns.jcp.org/xml/ns/persistence/orm}access-type" minOccurs="0"/>
 *         &lt;element name="sequence-generator" type="{http://xmlns.jcp.org/xml/ns/persistence/orm}sequence-generator" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="table-generator" type="{http://xmlns.jcp.org/xml/ns/persistence/orm}table-generator" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="named-query" type="{http://xmlns.jcp.org/xml/ns/persistence/orm}named-query" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="named-native-query" type="{http://xmlns.jcp.org/xml/ns/persistence/orm}named-native-query" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="named-stored-procedure-query" type="{http://xmlns.jcp.org/xml/ns/persistence/orm}named-stored-procedure-query" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="sql-result-set-mapping" type="{http://xmlns.jcp.org/xml/ns/persistence/orm}sql-result-set-mapping" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="mapped-superclass" type="{http://xmlns.jcp.org/xml/ns/persistence/orm}mapped-superclass" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="entity" type="{http://xmlns.jcp.org/xml/ns/persistence/orm}entity" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="embeddable" type="{http://xmlns.jcp.org/xml/ns/persistence/orm}embeddable" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="converter" type="{http://xmlns.jcp.org/xml/ns/persistence/orm}converter" maxOccurs="unbounded" minOccurs="0"/>
 *       &lt;/sequence>
 *       &lt;attribute name="version" use="required" type="{http://java.sun.com/xml/ns/persistence/orm}versionType" fixed="2.0" />
 *     &lt;/restriction>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 *
 *
 */
@XmlType(name = "entity-mappings", propOrder = {
    "description",
    "schema",
    "catalog",
    "access",
    "sequenceGenerator",
    "tableGenerator",
    "namedQuery",
    "namedNativeQuery",
    "namedStoredProcedureQuery",
    "sqlResultSetMapping",
    "mappedSuperclass",
    "entity",
    "embeddable",
    "beanClass",
    "converter",
    "snippets",
    "interfaces",
    "cache",
    "jsonbDateFormat",
    "jsonbNumberFormat",
    "jsonbVisibility",
    "jpaDiagram",
    "workSpaces"
})
@XmlRootElement(name = "entity-mappings")
@XmlAccessorType(XmlAccessType.FIELD)
public class EntityMappings extends BaseElement implements IDefinitionElement, IRootElement,
        org.netbeans.modeler.properties.type.Embedded, JsonbVisibilityHandler {

    private static final String DEFAULT_PU_NAME = "DEFAULT_PU";

    protected String description;
    @XmlAttribute(name = "ptype")
    private ProjectType projectType;
    @XmlAttribute(name = "ppkg")
    private String projectPackage;
    @XmlAttribute(name = "epkg")
    private String entityPackage;
    @XmlAttribute(name = "pkg")//for backward compatibility 
    private String _package;
    protected String schema;
    protected String catalog;
    protected AccessType access;
    @XmlElement(name = "sequence-generator")
    protected List<SequenceGenerator> sequenceGenerator;
    @XmlElement(name = "table-generator")
    protected List<TableGenerator> tableGenerator;
    @XmlElement(name = "nq")//(name = "named-query")
    protected List<NamedQuery> namedQuery;
    @XmlElement(name = "nnq")//(name = "named-native-query")
    protected List<NamedNativeQuery> namedNativeQuery;
    @XmlElement(name = "nspq")//(name = "named-stored-procedure-query")
    protected List<NamedStoredProcedureQuery> namedStoredProcedureQuery;
    @XmlElement(name = "srsm")//(name = "sql-result-set-mapping")
    protected Set<SqlResultSetMapping> sqlResultSetMapping;

    @XmlTransient
    private List<DefaultClass> defaultClass;
    @XmlElement(name = "mapped-superclass")
    protected List<MappedSuperclass> mappedSuperclass;
    protected List<Entity> entity;
    protected List<Embeddable> embeddable;
    protected List<BeanClass> beanClass;
    protected List<Converter> converter;//NREVENG 
    @XmlAttribute(name = "v", required = true)
    protected String version;
    @XmlTransient
    private SoftwareVersion previousVersion;
    @XmlAttribute(name = "dv")
    private String diagramVersion;
    @XmlElement(name = "diagram")
    private Diagram jpaDiagram;//Custom Added

    @XmlAttribute(name = "rws")
    @XmlIDREF
    private WorkSpace rootWorkSpace;
    @XmlAttribute(name = "Pws")
    @XmlIDREF
    private WorkSpace previousWorkSpace;
    @XmlAttribute(name = "cws")
    @XmlIDREF
    private WorkSpace currentWorkSpace;
    @XmlAttribute(name = "nws")
    @XmlIDREF
    private WorkSpace nextWorkSpace;
    @XmlElementWrapper(name = "wsl")
    @XmlElement(name = "ws")
    private List<WorkSpace> workSpaces;

    @XmlAttribute
    private String status;//GENERATED (DBRE,JCRE)
    @XmlAttribute(name = "thm")
    private String theme;
    @XmlAttribute(name = "dbthm")
    private String dbTheme;
    @XmlAttribute(name = "jbthm")
    private String jbTheme;
    
    @XmlAttribute(name = "pu")
    private Boolean generatePersistenceUnit;
    @XmlAttribute
    private String persistenceUnitName;
    @XmlAttribute(name = "pp")
    private PersistenceProviderType persistenceProviderType;

    @XmlElement(name = "c")
    private Cache cache;
    @XmlAttribute(name = "sm")
    private Boolean generateStaticMetamodel = false;
    @XmlAttribute(name = "smpkg")
    private String staticMetamodelPackage;

    /**
     * JAXB support
     */
    @XmlAttribute(name = "xs")
    private Boolean jaxbSupport;

    @XmlAttribute(name = "xn")
    private String jaxbNameSpace;

    //Jsonb support start
    @XmlAttribute(name = "jbpns")
    private PropertyNamingStrategy jsonbPropertyNamingStrategy;

    @XmlAttribute(name = "jbpos")
    private PropertyOrderStrategy jsonbPropertyOrderStrategy;

    @XmlAttribute(name = "jbn")
    private Boolean jsonbNillable;//REVENG pending

    @XmlElement(name = "jbdf")
    private JsonbDateFormat jsonbDateFormat;//REVENG pending

    @XmlElement(name = "jbnf")
    private JsonbNumberFormat jsonbNumberFormat;//REVENG pending

    @XmlElement(name = "jbv")
    private ReferenceClass jsonbVisibility;//REVENG pending

    //Jsonb support end
    @XmlElement(name = "snp")
    private List<ClassSnippet> snippets;

    @XmlElement(name = "inf")
    private Set<ReferenceClass> interfaces;

    private static final ClassSnippet DEAFULT_SNIPPET;
    private static final ReferenceClass DEAFULT_INTERFACE;

    static {
        DEAFULT_SNIPPET = new ClassSnippet();
        DEAFULT_SNIPPET.setValue("/**\n"
                + " * This file was generated by the Jeddict\n"
                + " */");
        DEAFULT_SNIPPET.setLocationType(ClassSnippetLocationType.BEFORE_PACKAGE);

        DEAFULT_INTERFACE = new ReferenceClass(Serializable.class.getCanonicalName());
    }

    private EntityMappings() {
    }

    public void initJavaInheritanceMapping() {
        List<JavaClass> javaClassList = this.getJavaClass();
        javaClassList.stream().filter((javaClass) -> (javaClass.getSuperclassId() != null)).forEach((javaClass) -> {
            JavaClass javaSuperclass = getJavaClass(javaClass.getSuperclassId());
            javaClass.addSuperclass(javaSuperclass);
        });
    }

    //UPDATE ELEMENT
    public boolean isClassExist(String _class) {
        if (mappedSuperclass != null) {
            if (mappedSuperclass.stream().anyMatch((e) -> (e.getClazz() != null && e.getClazz().equals(_class)))) {
                return true;
            }
        }
        if (entity != null) {
            if (entity.stream().anyMatch((e) -> (e.getClazz() != null && e.getClazz().equals(_class)))) {
                return true;
            }
        }
        if (embeddable != null) {
            if (embeddable.stream().anyMatch((e) -> (e.getClazz() != null && e.getClazz().equals(_class)))) {
                return true;
            }
        }
        if (getBeanClass() != null) {
            if (getBeanClass().stream().anyMatch((e) -> (e.getClazz() != null && e.getClazz().equals(_class)))) {
                return true;
            }
        }

        return false;
    }

    /**
     * Gets the value of the description property.
     *
     * @return possible object is {@link String }
     *
     */
    public String getDescription() {
        return description;
    }

    /**
     * Sets the value of the description property.
     *
     * @param value allowed object is {@link String }
     *
     */
    public void setDescription(String value) {
        this.description = value;
    }

    /**
     * @return the persistenceProviderType
     */
    public PersistenceProviderType getPersistenceProviderType() {
        return persistenceProviderType;
    }

    /**
     * @param persistenceProviderType the persistenceProviderType to set
     */
    public void setPersistenceProviderType(PersistenceProviderType persistenceProviderType) {
        this.persistenceProviderType = persistenceProviderType;
    }

    /**
     * @return the projectType
     */
    public ProjectType getProjectType() {
        return projectType;
    }

    /**
     * @param projectType the projectType to set
     */
    public void setProjectType(ProjectType projectType) {
        this.projectType = projectType;
    }

    /**
     * Gets the value of the package property.
     *
     * @return possible object is {@link String }
     *
     */
    public String getPackage() {
        return mergePackage(getProjectPackage(), getEntityPackage());
    }

    /**
     * @return the projectPackage
     */
    public String getProjectPackage() {
        return projectPackage;
    }

    /**
     * @param projectPackage the projectPackage to set
     */
    public void setProjectPackage(String projectPackage) {
        this.projectPackage = projectPackage;
    }

    /**
     * @return the entityPackage
     */
    public String getEntityPackage() {
        return entityPackage;
    }

    /**
     * @param entityPackage the entityPackage to set
     */
    public void setEntityPackage(String entityPackage) {
        this.entityPackage = entityPackage;
    }

    /**
     * Gets the value of the schema property.
     *
     * @return possible object is {@link String }
     *
     */
    public String getSchema() {
        return schema;
    }

    /**
     * Sets the value of the schema property.
     *
     * @param value allowed object is {@link String }
     *
     */
    public void setSchema(String value) {
        this.schema = value;
    }

    /**
     * Gets the value of the catalog property.
     *
     * @return possible object is {@link String }
     *
     */
    public String getCatalog() {
        return catalog;
    }

    /**
     * Sets the value of the catalog property.
     *
     * @param value allowed object is {@link String }
     *
     */
    public void setCatalog(String value) {
        this.catalog = value;
    }

    /**
     * Gets the value of the access property.
     *
     * @return possible object is {@link AccessType }
     *
     */
    public AccessType getAccess() {
        return access;
    }

    /**
     * Sets the value of the access property.
     *
     * @param value allowed object is {@link AccessType }
     *
     */
    public void setAccess(AccessType value) {
        this.access = value;
    }

    /**
     * Gets the value of the sequenceGenerator property.
     *
     * <p>
     * This accessor method returns a reference to the live list, not a
     * snapshot. Therefore any modification you make to the returned list will
     * be present inside the JAXB object. This is why there is not a
     * <CODE>set</CODE> method for the sequenceGenerator property.
     *
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSequenceGenerator().add(newItem);
     * </pre>
     *
     *
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link SequenceGenerator }
     *
     *
     */
    public List<SequenceGenerator> getSequenceGenerator() {
        if (sequenceGenerator == null) {
            sequenceGenerator = new ArrayList<>();
        }
        return this.sequenceGenerator;
    }

    /**
     * Gets the value of the tableGenerator property.
     *
     * <p>
     * This accessor method returns a reference to the live list, not a
     * snapshot. Therefore any modification you make to the returned list will
     * be present inside the JAXB object. This is why there is not a
     * <CODE>set</CODE> method for the tableGenerator property.
     *
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getTableGenerator().add(newItem);
     * </pre>
     *
     *
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link TableGenerator }
     *
     *
     */
    public List<TableGenerator> getTableGenerator() {
        if (tableGenerator == null) {
            tableGenerator = new ArrayList<>();
        }
        return this.tableGenerator;
    }

    /**
     * Gets the value of the namedQuery property.
     *
     * <p>
     * This accessor method returns a reference to the live list, not a
     * snapshot. Therefore any modification you make to the returned list will
     * be present inside the JAXB object. This is why there is not a
     * <CODE>set</CODE> method for the namedQuery property.
     *
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getNamedQuery().add(newItem);
     * </pre>
     *
     *
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link NamedQuery }
     *
     *
     */
    public List<NamedQuery> getNamedQuery() {
        if (namedQuery == null) {
            namedQuery = new ArrayList<>();
        }
        return this.namedQuery;
    }

    /**
     * Gets the value of the namedNativeQuery property.
     *
     * <p>
     * This accessor method returns a reference to the live list, not a
     * snapshot. Therefore any modification you make to the returned list will
     * be present inside the JAXB object. This is why there is not a
     * <CODE>set</CODE> method for the namedNativeQuery property.
     *
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getNamedNativeQuery().add(newItem);
     * </pre>
     *
     *
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link NamedNativeQuery }
     *
     *
     */
    public List<NamedNativeQuery> getNamedNativeQuery() {
        if (namedNativeQuery == null) {
            namedNativeQuery = new ArrayList<>();
        }
        return this.namedNativeQuery;
    }

    /**
     * Gets the value of the namedStoredProcedureQuery property.
     *
     * <p>
     * This accessor method returns a reference to the live list, not a
     * snapshot. Therefore any modification you make to the returned list will
     * be present inside the JAXB object. This is why there is not a
     * <CODE>set</CODE> method for the namedStoredProcedureQuery property.
     *
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getNamedStoredProcedureQuery().add(newItem);
     * </pre>
     *
     *
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link NamedStoredProcedureQuery }
     *
     *
     */
    public List<NamedStoredProcedureQuery> getNamedStoredProcedureQuery() {
        if (namedStoredProcedureQuery == null) {
            namedStoredProcedureQuery = new ArrayList<>();
        }
        return this.namedStoredProcedureQuery;
    }

    /**
     * Gets the value of the sqlResultSetMapping property.
     *
     * <p>
     * This accessor method returns a reference to the live list, not a
     * snapshot. Therefore any modification you make to the returned list will
     * be present inside the JAXB object. This is why there is not a
     * <CODE>set</CODE> method for the sqlResultSetMapping property.
     *
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSqlResultSetMapping().add(newItem);
     * </pre>
     *
     *
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link SqlResultSetMapping }
     *
     *
     */
    public Set<SqlResultSetMapping> getSqlResultSetMapping() {
        if (sqlResultSetMapping == null) {
            sqlResultSetMapping = new HashSet<>();
        }
        return this.sqlResultSetMapping;
    }

    /**
     * Gets the value of the mappedSuperclass property.
     *
     * <p>
     * This accessor method returns a reference to the live list, not a
     * snapshot. Therefore any modification you make to the returned list will
     * be present inside the JAXB object. This is why there is not a
     * <CODE>set</CODE> method for the mappedSuperclass property.
     *
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getMappedSuperclass().add(newItem);
     * </pre>
     *
     *
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link MappedSuperclass }
     *
     *
     */
    public List<MappedSuperclass> getMappedSuperclass() {
        if (mappedSuperclass == null) {
            mappedSuperclass = new ArrayList<>();
        }
        return this.mappedSuperclass;
    }

    public MappedSuperclass getMappedSuperclass(String id) {
        if (mappedSuperclass != null) {
            for (MappedSuperclass mappedSuperclass_In : mappedSuperclass) {
                if (id.equals(mappedSuperclass_In.getId())) {
                    return mappedSuperclass_In;
                }
            }
        }
        return null;
    }

    public void setMappedSuperclass(List<MappedSuperclass> mappedSuperclass) {
        if (this.mappedSuperclass == null) {
            this.mappedSuperclass = new ArrayList<>();
        }
        this.mappedSuperclass = mappedSuperclass;
    }

    /**
     * Gets the value of the entity property.
     *
     * <p>
     * This accessor method returns a reference to the live list, not a
     * snapshot. Therefore any modification you make to the returned list will
     * be present inside the JAXB object. This is why there is not a
     * <CODE>set</CODE> method for the entity property.
     *
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getEntity().add(newItem);
     * </pre>
     *
     *
     * <p>
     * Objects of the following type(s) are allowed in the list {@link Entity }
     *
     *
     * @return
     */
    public List<Entity> getEntity() {
        if (entity == null) {
            entity = new ArrayList<>();
        }
        return this.entity;
    }

    public Stream<String> getFQEntity() {
        return getEntity().stream().map(Entity::getFQN);
    }

    public Stream<String> getFQConcreteEntity() {
        return getConcreteEntity().map(Entity::getFQN);
    }

    public Stream<Entity> getConcreteEntity() {
        return getEntity().stream().filter(e -> Boolean.FALSE.equals(e.getAbstract()));
    }

    public Stream<Entity> getGeneratedEntity() {
        return getEntity().stream()
                .filter(e -> Boolean.FALSE.equals(e.getAbstract()))
                .filter(Entity::getGenerateSourceCode);
    }

    public void setEntity(List<Entity> entity) {
        if (this.entity == null) {
            this.entity = new ArrayList<>();
        }
        this.entity = entity;
    }

    /**
     * Gets the value of the embeddable property.
     *
     * <p>
     * This accessor method returns a reference to the live list, not a
     * snapshot. Therefore any modification you make to the returned list will
     * be present inside the JAXB object. This is why there is not a
     * <CODE>set</CODE> method for the embeddable property.
     *
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getEmbeddable().add(newItem);
     * </pre>
     *
     *
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Embeddable }
     *
     *
     */
    public List<Embeddable> getEmbeddable() {
        if (embeddable == null) {
            embeddable = new ArrayList<>();
        }
        return this.embeddable;
    }

    public void setEmbeddable(List<Embeddable> embeddable) {
        if (this.embeddable == null) {
            this.embeddable = new ArrayList<>();
        }
        this.embeddable = embeddable;
    }

    /**
     * @return the beanClass
     */
    public List<BeanClass> getBeanClass() {
        if (this.beanClass == null) {
            this.beanClass = new ArrayList<>();
        }
        return beanClass;
    }

    /**
     * @param beanClass the beanClass to set
     */
    public void setBeanClass(List<BeanClass> beanClass) {
        if (this.beanClass == null) {
            this.beanClass = new ArrayList<>();
        }
        this.beanClass = beanClass;
    }

    /**
     * Gets the value of the converter property.
     *
     * <p>
     * This accessor method returns a reference to the live list, not a
     * snapshot. Therefore any modification you make to the returned list will
     * be present inside the JAXB object. This is why there is not a
     * <CODE>set</CODE> method for the converter property.
     *
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getConverter().add(newItem);
     * </pre>
     *
     *
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Converter }
     *
     *
     */
    public List<Converter> getConverter() {
        if (converter == null) {
            converter = new ArrayList<>();
        }
        return this.converter;
    }

    public Optional<Converter> findConverter(String converter) {
        if (StringUtils.isBlank(converter)) {
            return Optional.empty();
        }
        for (Converter converter_In : getConverter()) {
            if (converter.equals(converter_In.getClazz())) {
                return Optional.of(converter_In);
            }
        }
        return Optional.empty();
    }

    public boolean addConverter(String converterClass, String attributeType, String dbFieldType) {
        Optional<Converter> existingConOpt = findConverter(converterClass);
        if (existingConOpt.isPresent()) {
            Converter existingCon = existingConOpt.get();
            return attributeType.equals(existingCon.getAttributeType()) && dbFieldType.equals(existingCon.getFieldType());
        } else {
            Converter newConverter = new Converter();
            newConverter.setClazz(converterClass);
            newConverter.setFieldType(dbFieldType);
            newConverter.setAttributeType(attributeType);
            getConverter().add(newConverter);
            return true;
        }
    }

    /**
     * Gets the value of the version property.
     *
     * @return possible object is {@link String }
     *
     */
    public String getVersion() {
        if (StringUtils.isBlank(version)) {
            version = "0.0";
        }
        return version;
    }

    /**
     * Sets the value of the version property.
     *
     * @param value allowed object is {@link float }
     *
     */
    public void setVersion(String value) {
        this.version = value;
    }

    public void setVersion(SoftwareVersion value) {
        this.version = value.getValue();
    }

    @Override
    public void removeBaseElement(IBaseElement baseElement_In) {
        if (baseElement_In instanceof JavaClass) {
            if (baseElement_In instanceof Entity) {
                this.removeEntity((Entity) baseElement_In);
            } else if (baseElement_In instanceof MappedSuperclass) {
                this.removeMappedSuperclass((MappedSuperclass) baseElement_In);
            } else if (baseElement_In instanceof Embeddable) {
                this.removeEmbeddable((Embeddable) baseElement_In);
            } else if (baseElement_In instanceof BeanClass) {
                this.removeBeanClass((BeanClass) baseElement_In);
            } else {
                throw new InvalidElmentException("Invalid JPA Element");
            }
            getCurrentWorkSpace().removeItem(new WorkSpaceItem((JavaClass) baseElement_In));
        } else {
            throw new InvalidElmentException("Invalid JPA Element");
        }
    }

    @Override
    public void addBaseElement(IBaseElement baseElement_In) {
        if (baseElement_In instanceof JavaClass) {
            if (baseElement_In instanceof Entity) {
                this.addEntity((Entity) baseElement_In);
            } else if (baseElement_In instanceof MappedSuperclass) {
                this.addMappedSuperclass((MappedSuperclass) baseElement_In);
            } else if (baseElement_In instanceof Embeddable) {
                this.addEmbeddable((Embeddable) baseElement_In);
            } else if (baseElement_In instanceof BeanClass) {
                this.addBeanClass((BeanClass) baseElement_In);
            } else {
                throw new InvalidElmentException("Invalid JPA Element");
            }
            getCurrentWorkSpace().addItem(new WorkSpaceItem((JavaClass) baseElement_In));
        } else {
            throw new InvalidElmentException("Invalid JPA Element");
        }
    }

    public void removeEntity(Entity entity_In) {
        if (entity != null) {
            this.entity.remove(entity_In);
            entity_In.setRootElement(null);

            if (!this.isRootWorkSpace()) {
                for (JavaClass javaClass : getJavaClassesExcludingWP()) {
                    if (javaClass.getSuperclass() == entity_In) {
                        javaClass.removeSuperclass(entity_In);
                    }
                    if (javaClass.getAttributes() instanceof PersistenceAttributes) {
                        PersistenceAttributes<ManagedClass> attributes = (PersistenceAttributes<ManagedClass>) javaClass.getAttributes();
                        attributes.getRelationAttributes()
                                .stream()
                                .filter(attr -> attr.getConnectedEntity() == entity_In)
                                .forEach(attr -> attributes.removeRelationAttribute(attr));
                    }
                }
            }
        }
    }

    public void addEntity(Entity entity_In) {
        if (entity == null) {
            entity = new ArrayList<>();
        }
        this.entity.add(entity_In);
        entity_In.setRootElement(this);
    }

    public Optional<Entity> findEntity(String entityName) {
        if (StringUtils.isBlank(entityName)) {
            return Optional.empty();
        }
        if (entity != null) {
            for (Entity entity_In : entity) {
                if (entityName.equals(entity_In.getClazz())) {
                    return Optional.of(entity_In);
                }
            }
        }
        return Optional.empty();
    }

    public Optional<? extends IdentifiableClass> findIdentifiableClass(String className) {
        if (StringUtils.isBlank(className)) {
            return Optional.empty();
        }
        Optional<Entity> entityOpt = findEntity(className);
        if (!entityOpt.isPresent()) {
            return findMappedSuperclass(className);
        } else {
            return entityOpt;
        }
    }

    public Entity getEntity(String id) {
        if (isBlank(id)) {
            return null;
        }
        if (entity != null) {
            for (Entity entity_In : entity) {
                if (id.equals(entity_In.getId())) {
                    return entity_In;
                }
            }
        }
        return null;
    }

    public Embeddable getEmbeddable(String id) {
        if (isBlank(id)) {
            return null;
        }
        if (embeddable != null) {
            for (Embeddable embeddable_In : embeddable) {
                if (id.equals(embeddable_In.getId())) {
                    return embeddable_In;
                }
            }
        }
        return null;
    }

    public List<Entity> findAllEntity(String entityName) {
        if (isBlank(entityName)) {
            return null;
        }
        List<Entity> entities = new ArrayList<>();
        if (entity != null) {
            for (Entity entity_In : entity) {
                if (entityName.equals(entity_In.getClazz())) {
                    entities.add(entity_In);
                }
            }
        }
        return entities;
    }

    public void removeMappedSuperclass(MappedSuperclass mappedSuperclass_In) {
        if (mappedSuperclass != null) {
            this.mappedSuperclass.remove(mappedSuperclass_In);
            mappedSuperclass_In.setRootElement(null);

            if (!this.isRootWorkSpace()) {
                for (JavaClass javaClass : getJavaClassesExcludingWP()) {
                    if (javaClass.getSuperclass() == mappedSuperclass_In) {
                        javaClass.removeSuperclass(mappedSuperclass_In);
                    }
                }
            }
        }
    }

    public void addMappedSuperclass(MappedSuperclass mappedSuperclass_In) {
        if (mappedSuperclass == null) {
            mappedSuperclass = new ArrayList<>();
        }
        this.mappedSuperclass.add(mappedSuperclass_In);
        mappedSuperclass_In.setRootElement(this);
    }

    public Optional<MappedSuperclass> findMappedSuperclass(String mappedSuperclassName) {
        if (isBlank(mappedSuperclassName)) {
            return Optional.empty();
        }
        if (mappedSuperclass != null) {
            for (MappedSuperclass mappedSuperclass_In : mappedSuperclass) {
                if (mappedSuperclassName.equals(mappedSuperclass_In.getClazz())) {
                    return Optional.of(mappedSuperclass_In);
                }
            }
        }
        return Optional.empty();
    }

    public void removeEmbeddable(Embeddable embeddable_In) {
        if (embeddable != null) {
            this.embeddable.remove(embeddable_In);
            embeddable_In.setRootElement(null);

            if (!this.isRootWorkSpace()) {
                for (JavaClass javaClass : getJavaClassesExcludingWP()) {
                    if (javaClass.getAttributes() instanceof PersistenceAttributes) {
                        PersistenceAttributes<ManagedClass> attributes = (PersistenceAttributes<ManagedClass>) javaClass.getAttributes();
                        List<Embedded> names = attributes.getEmbedded();
                        Iterator<Embedded> i = names.iterator();
                        while (i.hasNext()) {
                            Embedded embedded = i.next();
                            if (embedded.getConnectedClass() == embeddable_In) {
                                i.remove();
                            }
                        }
                    }
                }
            }
        }
    }

    public void addEmbeddable(Embeddable embeddable_In) {
        if (embeddable == null) {
            embeddable = new ArrayList<>();
        }
        this.embeddable.add(embeddable_In);
        embeddable_In.setRootElement(this);
    }

    public Optional<Embeddable> findEmbeddable(String embeddableName) {
        if (isBlank(embeddableName)) {
            return Optional.empty();
        }
        if (embeddable != null) {
            for (Embeddable embeddable_In : embeddable) {
                if (embeddableName.equals(embeddable_In.getClazz())) {
                    return Optional.of(embeddable_In);
                }
            }
        }
        return Optional.empty();
    }

    public void removeBeanClass(BeanClass class_In) {
        if (getBeanClass() != null) {
            this.getBeanClass().remove(class_In);
            class_In.setRootElement(null);
        }
    }

    public void addBeanClass(BeanClass class_In) {
        if (getBeanClass() == null) {
            setBeanClass(new ArrayList<>());
        }
        this.getBeanClass().add(class_In);
        class_In.setRootElement(this);
    }

    public Optional<BeanClass> findBeanClass(String className) {
        if (isBlank(className)) {
            return Optional.empty();
        }
        if (getBeanClass() != null) {
            for (BeanClass class_In : getBeanClass()) {
                if (className.equals(class_In.getClazz())) {
                    return Optional.of(class_In);
                }
            }
        }
        return Optional.empty();
    }

    /**
     * @return the jpaDiagram
     */
    @Deprecated
    public Diagram getJPADiagram() {
        return jpaDiagram;
    }

    /**
     * @param jpaDiagram the jpaDiagram to set
     */
    @Deprecated
    public void setJPADiagram(Diagram jpaDiagram) {
        this.jpaDiagram = jpaDiagram;
    }

    
    /**
     * @return the generatePersistenceUnit
     */
    public Boolean getGeneratePersistenceUnit() {
        if(generatePersistenceUnit == null){
            return true;
        }
        return generatePersistenceUnit;
    }

    /**
     * @param generatePersistenceUnit the generatePersistenceUnit to set
     */
    public void setGeneratePersistenceUnit(Boolean generatePersistenceUnit) {
        this.generatePersistenceUnit = generatePersistenceUnit;
    }
    
    /**
     * @return the persistenceUnitName
     */
    public String getPersistenceUnitName() {
        if(persistenceUnitName == null){
            persistenceUnitName = DEFAULT_PU_NAME;
        }
        return persistenceUnitName;
    }

    /**
     * @param persistenceUnitName the persistenceUnitName to set
     */
    public void setPersistenceUnitName(String persistenceUnitName) {
        this.persistenceUnitName = persistenceUnitName;
    }

    /**
     * @return the defaultClass
     */
    public List<DefaultClass> getDefaultClass() {
        if (this.defaultClass == null) {
            this.defaultClass = new ArrayList<>();
        }
        return defaultClass;
    }

    public DefaultClass addDefaultClass(String subPackage, String _class) {
        if (isBlank(_class)) {
            throw new IllegalStateException("Class name can't empty");
        }
        DefaultClass existDefaultClass;
//        Optional<DefaultClass> existDefaultClassOpt = findDefaultClass(_class);
//
//        if (!existDefaultClassOpt.isPresent()) {
        existDefaultClass = new DefaultClass(_class);
        existDefaultClass.setPackage(subPackage);
        existDefaultClass.setId(NBModelerUtil.getAutoGeneratedStringId());
        existDefaultClass.setRootElement(this);
        this.getDefaultClass().add(existDefaultClass);
//        } else {
//            existDefaultClass = existDefaultClassOpt.get();
//        }
        return existDefaultClass;
    }

    public Optional<DefaultClass> findDefaultClass(String _class) {
        if (this.defaultClass != null) {
            for (DefaultClass defaultClass_TMP : defaultClass) {
                if (defaultClass_TMP.getClazz().equals(_class)) {
                    return Optional.of(defaultClass_TMP);
                }
            }
        }
        return Optional.empty();
    }

    /**
     * @return the status
     */
    public String getStatus() {
        return status;
    }

    /**
     * @param status the status to set
     */
    public void setStatus(String status) {
        this.status = status;
    }

    public void setGenerated() {
        this.status = "GENERATED";
    }

    public boolean isGenerated() {
        if ("GENERATED".equals(this.status)) {
            return true;
        } else {
            return false;
        }
    }

    public List<IdentifiableClass> getIdentifiableClass() {
        List<IdentifiableClass> identifiableClasses = new ArrayList<>(getEntity());
        identifiableClasses.addAll(getMappedSuperclass());
        return identifiableClasses;
    }

    public void manageRefId() {
        EntityMappings entityMappingsSpec = this;

        getNamedStoredProcedureQuery().forEach(this::manageStoredProcedureQuery);

        // manageSiblingAttribute for MappedSuperClass and Embeddable is not required for (DBRE) DB REV ENG CASE
        for (ManagedClass<? extends IPersistenceAttributes> managedClass : entityMappingsSpec.getAllManagedClass()) {

            if (managedClass instanceof Entity) {
                ((Entity) managedClass).getNamedStoredProcedureQuery().forEach(this::manageStoredProcedureQuery);
            }

            for (ManyToMany manyToMany : new ArrayList<>(managedClass.getAttributes().getManyToMany())) {
                if (manyToMany.getMappedBy() == null) {
                    manageSiblingAttribute(managedClass, manyToMany);
                    manageMapKeyAttribute(managedClass, manyToMany);
                }
            }
            for (OneToMany oneToMany : new ArrayList<>(managedClass.getAttributes().getOneToMany())) {
                if (oneToMany.getMappedBy() == null) {
                    manageSiblingAttribute(managedClass, oneToMany);
                    manageMapKeyAttribute(managedClass, oneToMany);
                }
            }
            for (ManyToOne manyToOne : new ArrayList<>(managedClass.getAttributes().getManyToOne())) {
                manageSiblingAttribute(managedClass, manyToOne);
            }
            for (OneToOne oneToOne : new ArrayList<>(managedClass.getAttributes().getOneToOne())) {
                if (oneToOne.getMappedBy() == null) {
                    manageSiblingAttribute(managedClass, oneToOne);
                }
            }

            for (ElementCollection elementCollection : new ArrayList<>(managedClass.getAttributes().getElementCollection())) {
                if (elementCollection.getMapKeyAttributeType() != null) {
                    manageMapKeyAttribute(managedClass, elementCollection);
                }
            }

            // If Include Referenced Classed Checkbox is Uncheked then remove attribute
            for (RelationAttribute relationAttribute : new ArrayList<>(managedClass.getAttributes().getRelationAttributes())) {
                Optional<Entity> targetEntity = entityMappingsSpec.findEntity(relationAttribute.getTargetEntity());
                if (!targetEntity.isPresent()) {
                    managedClass.getAttributes().removeRelationAttribute(relationAttribute);
                }
            }

        }

    }

    private void manageStoredProcedureQuery(NamedStoredProcedureQuery storedProcedureQuery) {
        for (String _class : new CopyOnWriteArrayList<>(storedProcedureQuery.getResultClass())) {
            String uqClass = JavaSourceHelper.getSimpleClassName(_class);
            this.findEntity(uqClass).ifPresent(targetEntity -> {
                storedProcedureQuery.getResultClass().remove(_class);
                storedProcedureQuery.addResultClass(targetEntity);
            });
        }

    }

    private void manageMapKeyAttribute(ManagedClass managedClass, MapKeyHandler mapKeyHandler) {
        if (mapKeyHandler.getMapKeyAttributeType() == null) {
            return;
        }
        loadMapKeyAttribute(managedClass, mapKeyHandler);
        mapKeyHandler.setMapKeyType(mapKeyHandler.getValidatedMapKeyType());
    }

    private void loadMapKeyAttribute(ManagedClass managedClass, MapKeyHandler mapKeyHandler) {
        if (mapKeyHandler.getMapKeyType() == MapKeyType.NEW) {
            //Search in Entity
            Optional<Entity> entity = this.findEntity(mapKeyHandler.getMapKeyAttributeType());
            if (entity.isPresent()) {
                mapKeyHandler.setMapKeyEntity(entity.get());
                return;
            }

            //Search in Embeddable
            Optional<Embeddable> embeddableOpt = this.findEmbeddable(mapKeyHandler.getMapKeyAttributeType());
            if (embeddableOpt.isPresent()) {
                mapKeyHandler.setMapKeyEmbeddable(embeddableOpt.get());
                return;
            }
        } else {
            //find Existing Attribute in current and connected class based on the instance
            if (mapKeyHandler.getMapKey() != null && isNotBlank(mapKeyHandler.getMapKey().getName())) {
                ManagedClass attributeContainerClass = null;
                if (mapKeyHandler instanceof ElementCollection) {
                    attributeContainerClass = managedClass;
                } else if (mapKeyHandler instanceof MultiRelationAttribute) {
                    MultiRelationAttribute multiRelationAttribute = (MultiRelationAttribute) mapKeyHandler;
                    attributeContainerClass = multiRelationAttribute.getConnectedEntity();
                }
                if (attributeContainerClass != null) {
                    List<Attribute> attributes = attributeContainerClass.getAttributes().findAllAttribute(mapKeyHandler.getMapKey().getName());
                    if (attributes != null && !attributes.isEmpty()) {
                        mapKeyHandler.setMapKeyAttribute(attributes.get(0));
                    }
                }
            }
        }
    }

    // Issue Fix #5949 Start
    private void manageSiblingAttribute(JavaClass sourceJavaClass, RelationAttribute relationAttributeOwner) {
        Optional<Entity> targetEntityOptional = this.findEntity(relationAttributeOwner.getTargetEntity());
        if (targetEntityOptional.isPresent()) {
            Entity targetEntity = targetEntityOptional.get();
            if (relationAttributeOwner instanceof ManyToMany) {
                ManyToMany sourceAttribute = (ManyToMany) relationAttributeOwner;
                ManyToMany targetAttribute = null;
                for (ManyToMany targetManyToMany : targetEntity.getAttributes().getManyToMany()) {
                    if (sourceAttribute.getName().equals(targetManyToMany.getMappedBy())
                            && sourceJavaClass.getClazz().equals(targetManyToMany.getTargetEntity())) {
                        targetAttribute = targetManyToMany;
                        break;
                    }
                }
                if (targetAttribute != null) {
                    targetAttribute.setConnectedEntity((Entity) sourceJavaClass);
                    targetAttribute.setConnectedAttribute(sourceAttribute);
                    sourceAttribute.setConnectedAttribute(targetAttribute);
                }
                sourceAttribute.setConnectedEntity(targetEntity);
            } else if (relationAttributeOwner instanceof OneToMany) {
                OneToMany sourceAttribute = (OneToMany) relationAttributeOwner;
                sourceAttribute.setConnectedEntity(targetEntity);
            } else if (relationAttributeOwner instanceof ManyToOne) {
                ManyToOne sourceAttribute = (ManyToOne) relationAttributeOwner;
                OneToMany targetAttribute = null;
                for (OneToMany targetOneToMany : targetEntity.getAttributes().getOneToMany()) {
                    if (sourceAttribute.getName().equals(targetOneToMany.getMappedBy()) && sourceJavaClass.getClazz().equals(targetOneToMany.getTargetEntity())) {
                        targetAttribute = targetOneToMany;
                        break;
                    }
                }
                if (targetAttribute != null) {
                    targetAttribute.setConnectedEntity((Entity) sourceJavaClass);
                    targetAttribute.setConnectedAttribute(sourceAttribute);
                    sourceAttribute.setConnectedAttribute(targetAttribute);
                }
                sourceAttribute.setConnectedEntity(targetEntity);

            } else if (relationAttributeOwner instanceof OneToOne) {
                OneToOne sourceAttribute = (OneToOne) relationAttributeOwner;
                OneToOne targetAttribute = null;
                for (OneToOne targetOneToOne : targetEntity.getAttributes().getOneToOne()) {
                    if (sourceAttribute.getName().equals(targetOneToOne.getMappedBy()) && sourceJavaClass.getClazz().equals(targetOneToOne.getTargetEntity())) {
                        targetAttribute = targetOneToOne;
                        break;
                    }
                }
                if (targetAttribute != null) {
                    targetAttribute.setConnectedEntity((Entity) sourceJavaClass);
                    targetAttribute.setConnectedAttribute(sourceAttribute);
                    sourceAttribute.setConnectedAttribute(targetAttribute);
                }
                sourceAttribute.setConnectedEntity(targetEntity);

            }
        }
    }

    public void repairDefinition(InputOutput IO) {
        repairDefinition(IO, false);
    }

    /**
     * Helps in compatibility support to repair wrong jpa relation in JCRE
     *
     * @param IO
     * @param manageSiblingAttribute
     */
    public void repairDefinition(InputOutput IO, boolean manageSiblingAttribute) {

        for (ManagedClass<IPersistenceAttributes> managedClass : this.getAllManagedClass()) {
            for (RelationAttribute attribute : managedClass.getAttributes().getRelationAttributes()) {
                //if no connected-entity-id exist
                if (attribute.getConnectedEntity() == null) {
                    if (IO != null) {
                        StringBuilder message = new StringBuilder();
                        message.append("Repair action > ").append(managedClass.getClazz()).append('[');
                        message.append(attribute.getName()).append("]: ");
                        message.append("No connected entity reference found, so removing attribute").append('\n');
                        IO.getErr().print(message.toString());
                    }
                    if (attribute.getConnectedAttribute() != null) {
                        if (IO != null) {
                            StringBuilder message = new StringBuilder();
                            message.append("Repair action > ").append(managedClass.getClazz()).append('[');
                            message.append(attribute.getName()).append(" -> ").append(attribute.getConnectedAttribute().getName()).append("]: ");
                            message.append("Also removing connected attribute").append('\n');
                            IO.getErr().print(message.toString());
                        }
                        //remove the connected attribute from its owning class
                        ((ManagedClass<IPersistenceAttributes>) attribute.getConnectedAttribute().getJavaClass()).getAttributes().removeRelationAttribute(attribute.getConnectedAttribute());
                    }
                    //remove to self from owning class
                    managedClass.getAttributes().removeRelationAttribute(attribute);
                    continue;
                }
                //if own is missing/found form both side
                if (attribute.getConnectedAttribute() != null) {
                    if (attribute.isOwner() && attribute.getConnectedAttribute().isOwner()) {//if both true
                        if (IO != null) {
                            StringBuilder message = new StringBuilder();
                            message.append("Repair action > ").append(managedClass.getClazz()).append('[');
                            message.append(attribute.getName()).append(" -> ").append(attribute.getConnectedAttribute().getName()).append("]: ");
                            message.append("Both are owner so automatic removing owner role from ").append(attribute.getConnectedAttribute().getName()).append(" (converting to mappedBy)").append('\n');
                            IO.getErr().print(message.toString());
                        }
                        attribute.getConnectedAttribute().setOwner(false);
                    } else if (!attribute.isOwner() && !attribute.getConnectedAttribute().isOwner()) {//if both false
                        if (IO != null) {
                            StringBuilder message = new StringBuilder();
                            message.append("Repair action > ").append(managedClass.getClazz()).append('[');
                            message.append(attribute.getName()).append(" -> ").append(attribute.getConnectedAttribute().getName()).append("]: ");
                            message.append("Both are not owner so automatic adding owner role (not mappedBy) to ").append(attribute.getName()).append('\n');
                            IO.getErr().print(message.toString());
                        }
                        attribute.setOwner(true);
                        manageSiblingAttribute(managedClass, attribute);
                    }
                } else {
                    if (!attribute.isOwner()) {
                        if (IO != null) {
                            StringBuilder message = new StringBuilder();
                            message.append("Repair action > ").append(managedClass.getClazz()).append('[').append(attribute.getName()).append("]: ");
                            message.append("It is Unidirection relationship so automatic adding owner role and removing mappedBy").append('\n');
                            IO.getErr().print(message.toString());
                        }
                        attribute.setOwner(true);
                        manageSiblingAttribute(managedClass, attribute);
                    }
                }
            }
        }
    }

    /**
     * @return the theme
     */
    public String getTheme() {
        return theme;
    }

    /**
     * @param theme the theme to set
     */
    public void setTheme(String theme) {
        this.theme = theme;
    }

    public List<ManagedClass> getManagedClass() {
        List<ManagedClass> managedClassList = new ArrayList<>(this.getEntity());
        managedClassList.addAll(this.getMappedSuperclass());
        managedClassList.addAll(this.getEmbeddable());
        return managedClassList;
    }

    public List<JavaClass> getJavaClass() {
        List<JavaClass> javaClassList = new ArrayList<>(this.getManagedClass());
        javaClassList.addAll(getBeanClass());
        return javaClassList;
    }

    public JavaClass getJavaClass(String classId) {
        if (isBlank(classId)) {
            return null;
        }
        for (JavaClass javaClass : getJavaClass()) {
            if (StringUtils.equals(javaClass.getId(), classId)) {
                return javaClass;
            }
        }
        return null;
    }

    public List<JavaClass> getAllJavaClass() {
        List<JavaClass> classes = new ArrayList<>();
        classes.addAll(getEntity());
        classes.addAll(getMappedSuperclass());
        classes.addAll(getEmbeddable());
        classes.addAll(getDefaultClass());
        classes.addAll(getBeanClass());
        return classes;
    }

    public List<JavaClass> findAllJavaClass(String className) {
        return getAllJavaClass()
                .stream()
                .filter(_class -> _class.getClazz().equals(className))
                .collect(toList());
    }

    public List<JavaClass> getSubClass(String classId) {
        List<JavaClass> javaClassList = new ArrayList<>(this.getEntity());
        javaClassList.addAll(
                this.getJavaClass()
                        .stream()
                        .filter(javaClass -> classId.equals(javaClass.getSuperclass().getId()))
                        .collect(toList())
        );
        return javaClassList;
    }

    public List<JavaClass> getAllSubClass(String classId) {
        List<JavaClass> javaClassList = new ArrayList<>();
        for (JavaClass javaClass : this.getJavaClass()) {
            if (javaClass.getSuperclass() != null && classId.equals(javaClass.getSuperclass().getId())) {
                javaClassList.add(javaClass);
                javaClassList.addAll(this.getAllSubClass(javaClass.getId()));
            }
        }
        return javaClassList;
    }

    @Override
    public String getName() {
        return getPersistenceUnitName();
    }

    @Override
    public void setName(String persistenceUnitName) {
        setPersistenceUnitName(persistenceUnitName);
    }

    /**
     * @return the jaxbNameSpace
     */
    public String getJaxbNameSpace() {
        return jaxbNameSpace;
    }

    /**
     * @param jaxbNameSpace the jaxbNameSpace to set
     */
    public void setJaxbNameSpace(String jaxbNameSpace) {
        this.jaxbNameSpace = jaxbNameSpace;
    }

    public static EntityMappings getNewInstance(String version) {

        EntityMappings entityMappingsSpec = new EntityMappings();
        entityMappingsSpec.setId(NBModelerUtil.getAutoGeneratedStringId());
        entityMappingsSpec.setVersion(version);
        entityMappingsSpec.setPreviousVersion(version);
        entityMappingsSpec.setPersistenceUnitName(DEFAULT_PU_NAME);
//        entityMappingsSpec.getSnippets().add(DEAFULT_SNIPPET);
//      entityMappingsSpec.getInterfaces().add(DEAFULT_INTERFACE);
        return entityMappingsSpec;
    }

    public List<SqlResultSetMapping> getAllSqlResultSetMappings() {
        List<IdentifiableClass> identifiableClasses = new ArrayList<>(this.getEntity());
        identifiableClasses.addAll(this.getMappedSuperclass());
        List<SqlResultSetMapping> sqlResultSetMappings = new ArrayList<>();
        identifiableClasses.forEach(identifiableClass -> sqlResultSetMappings.addAll(identifiableClass.getSqlResultSetMapping()));
        return sqlResultSetMappings;
    }

    /**
     * @return the cache
     */
    public Cache getCache() {
        if (cache == null) {
            cache = new Cache();
        }
        return cache;
    }

    /**
     * @param cache the cache to set
     */
    public void setCache(Cache cache) {
        this.cache = cache;
    }

    void afterUnmarshal(Unmarshaller u, Object parent) {
        setPreviousVersion(version);
        if (isEmpty(entityPackage) && !isEmpty(_package)) {
            entityPackage = _package;
            _package = null;
        }
    }

    /**
     * @param previousVersion the previousVersion to set
     */
    public void setPreviousVersion(String previousVersion) {
        if (isBlank(previousVersion)) {
            previousVersion = "0.0";
        }
        this.previousVersion = new SoftwareVersion(previousVersion);
    }

    /**
     * @return the previousVersion
     */
    public SoftwareVersion getPreviousVersion() {
        return previousVersion;
    }

    /**
     * @return the diagramVersion
     */
    public String getDiagramVersion() {
        return diagramVersion;
    }

    /**
     * @param diagramVersion the diagramVersion to set
     */
    public void setDiagramVersion(String diagramVersion) {
        this.diagramVersion = diagramVersion;
    }

    /**
     * @return the generateStaticMetamodel
     */
    public Boolean getGenerateStaticMetamodel() {
        return generateStaticMetamodel;
    }

    /**
     * @param generateStaticMetamodel the generateStaticMetamodel to set
     */
    public void setGenerateStaticMetamodel(Boolean generateStaticMetamodel) {
        this.generateStaticMetamodel = generateStaticMetamodel;
    }
    
    public List<ManagedClass> getAllManagedClass() {
        List<ManagedClass> managedClasses = new ArrayList<>();
        managedClasses.addAll(getEntity());
        managedClasses.addAll(getMappedSuperclass());
        managedClasses.addAll(getEmbeddable());
        return managedClasses;
    }

    /**
     * @return the staticMetamodelPackage
     */
    public String getStaticMetamodelPackage() {
        return staticMetamodelPackage;
    }

    /**
     * @param staticMetamodelPackage the staticMetamodelPackage to set
     */
    public void setStaticMetamodelPackage(String staticMetamodelPackage) {
        this.staticMetamodelPackage = staticMetamodelPackage;
    }

    /**
     * @return the dbTheme
     */
    public String getDbTheme() {
        return dbTheme;
    }

    /**
     * @param dbTheme the dbTheme to set
     */
    public void setDbTheme(String dbTheme) {
        this.dbTheme = dbTheme;
    }

    /**
     * @return the snippets
     */
    public List<ClassSnippet> getSnippets() {
        if (snippets == null) {
            snippets = new ArrayList<>();
        }
        return snippets;
    }

    /**
     * @param locationType
     * @return the snippets
     */
    public List<ClassSnippet> getSnippets(ClassSnippetLocationType locationType) {
        return getSnippets()
                .stream()
                .filter(snippet -> snippet.isEnable())
                .filter(snippet -> snippet.getLocationType() == locationType)
                .collect(toList());
    }

    /**
     * @param snippets the snippets to set
     */
    public void setSnippets(List<ClassSnippet> snippets) {
        this.snippets = snippets;
    }

    public boolean addSnippet(ClassSnippet snippet) {
        return getSnippets().add(snippet);
    }

    public boolean removeSnippet(ClassSnippet snippet) {
        return getSnippets().remove(snippet);
    }

    public void addInterface(ReferenceClass _interface) {
        this.getInterfaces().add(_interface);
    }

    public void removeInterface(ReferenceClass _interface) {
        this.getInterfaces().remove(_interface);
    }

    /**
     * @return the interfaces
     */
    public Set<ReferenceClass> getInterfaces() {
        if (this.interfaces == null) {
            this.interfaces = new LinkedHashSet<>();
        }
        return interfaces;
    }

    /**
     * @param interfaces the interfaces to set
     */
    public void setInterfaces(Set<ReferenceClass> interfaces) {
        this.interfaces = interfaces;
    }

    public boolean isCompositePrimaryKeyClass(String className) {
        return getEntity()
                .stream()
                .filter(entity -> className.equals(entity.getCompositePrimaryKeyClass()))
                .findAny()
                .isPresent();
    }

    public Set<String> getAllConvert() {
        Set<String> converts = new HashSet<>();
        for (Entity clazz : getEntity()) {
            converts.addAll(clazz.getAllConvert());
        }
        for (MappedSuperclass clazz : getMappedSuperclass()) {
            converts.addAll(clazz.getAllConvert());
        }
        for (Embeddable clazz : getEmbeddable()) {
            converts.addAll(clazz.getAllConvert());
        }
        return converts;
    }

    public void cleanRuntimeArtifact() {
        for (JavaClass javaClass : getJavaClass()) {
            javaClass.setRuntimeTypeParameters(null);
            javaClass.setRuntimeSuperclassRef(null);
            javaClass.setRuntimeInterfaces(null);
            javaClass.setRuntimeAnnotation(null);
            javaClass.setRuntimeSnippets(null);
            javaClass.resetRemovedAttributes();
            javaClass.resetPreviousClass();
            List<? extends Attribute> attributes = null;
            if (javaClass instanceof ManagedClass) {
                attributes = ((ManagedClass) javaClass).getAttributes().getAllAttribute();
            } else if (javaClass instanceof DefaultClass) {
                attributes = ((DefaultClass) javaClass).getAttributes().getDefaultAttributes();
            }
            if (attributes != null) {
                attributes.forEach(attr -> {
                    attr.setRuntimeAnnotation(null);
                    attr.setRuntimeSnippets(null);
                    attr.resetPreviousName();
                });
            }
        }
    }

    /**
     * @return the rootWorkSpace
     */
    public WorkSpace getRootWorkSpace() {
        if (rootWorkSpace == null) {
            rootWorkSpace = new WorkSpace();
            rootWorkSpace.setId(NBModelerUtil.getAutoGeneratedStringId());
            rootWorkSpace.setName("Main");
            getWorkSpaces().add(rootWorkSpace);
        }
        return rootWorkSpace;
    }

    /**
     * @param rootWorkSpace the rootWorkSpace to set
     */
    public void setRootWorkSpace(WorkSpace rootWorkSpace) {
        this.rootWorkSpace = rootWorkSpace;
    }

    public boolean isRootWorkSpace() {
        return getCurrentWorkSpace() == getRootWorkSpace();
    }

    public List<JavaClass> getJavaClassesExcludingWP() {
        List<JavaClass> javaClasses = new ArrayList<>(getAllJavaClass());

        javaClasses.removeAll(getCurrentWorkSpace()
                .getItems()
                .stream()
                .map(wi -> wi.getJavaClass())
                .collect(toList()));
        return javaClasses;
    }

    /**
     * @return the previousWorkSpace
     */
    public WorkSpace getPreviousWorkSpace() {
        return previousWorkSpace;
    }

    /**
     * @param previousWorkSpace the previousWorkSpace to set
     */
    private void setPreviousWorkSpace(WorkSpace previousWorkSpace) {
        this.previousWorkSpace = previousWorkSpace;
    }

    /**
     * @return the currentWorkSpace
     */
    public WorkSpace getCurrentWorkSpace() {
        if (currentWorkSpace == null) {
            return getRootWorkSpace();
        }
        return currentWorkSpace;
    }

    public void setGenerateWorkSpaceClass(WorkSpace workspace) {
        assert (workspace != null);
        getAllJavaClass()
                .forEach(jc -> jc.setGenerateSourceCode(false));
        getAllJavaClass()
                .stream()
                .filter(jc -> workspace.hasItem(jc))
                .forEach(jc -> jc.setGenerateSourceCode(true));
    }

    public Optional<WorkSpace> findGeneratedWorkSpace() {
        Set<WorkSpaceItem> selectedWorkSpaceItems = getAllJavaClass()
                .stream()
                .filter(c -> c.getGenerateSourceCode())
                .map(WorkSpaceItem::new)
                .collect(toSet());
        Optional<WorkSpace> optionalWorkSpace = getWorkSpaces()
                .stream()
                .filter(ws -> ws.getItems().equals(selectedWorkSpaceItems))
                .findAny();
        return optionalWorkSpace;
    }

    public List<JavaClass> findGeneratedClass() {
        return getAllJavaClass()
                .stream()
                .filter(c -> c.getGenerateSourceCode())
                .collect(toList());
    }

    /**
     * @param currentWorkSpace the currentWorkSpace to set
     */
    public void setCurrentWorkSpace(WorkSpace currentWorkSpace) {
        setPreviousWorkSpace(this.currentWorkSpace);
        this.currentWorkSpace = currentWorkSpace;
    }

    public void setCurrentWorkSpace(String currentWorkSpaceId) {
        Optional<WorkSpace> wsOptional = findWorkSpace(currentWorkSpaceId);
        if (wsOptional.isPresent()) {
            this.currentWorkSpace = wsOptional.get();
        }
    }

    /**
     * @return the nextWorkSpace
     */
    public WorkSpace getNextWorkSpace() {
        if (nextWorkSpace == null) {
            return getCurrentWorkSpace();
        }
        return nextWorkSpace;
    }

    /**
     * @param nextWorkSpace the nextWorkSpace to set
     */
    public void setNextWorkSpace(WorkSpace nextWorkSpace) {
        this.nextWorkSpace = nextWorkSpace;
    }

    /**
     * @return the workSpaces
     */
    public List<WorkSpace> getWorkSpaces() {
        if (workSpaces == null) {
            workSpaces = new ArrayList<>();
        }
        return workSpaces;
    }

    /**
     * @param workSpaces the workSpaces to set
     */
    public void setWorkSpaces(List<WorkSpace> workSpaces) {
        this.workSpaces = workSpaces;
    }

    public void addWorkSpace(WorkSpace workSpace) {
        getWorkSpaces().add(workSpace);
    }

    public void removeWorkSpace(WorkSpace workSpace) {
        getWorkSpaces().remove(workSpace);
    }

    public void removeAllWorkSpace() {
        getWorkSpaces().clear();
        getWorkSpaces().add(getRootWorkSpace());
        setCurrentWorkSpace((WorkSpace) null);
        setNextWorkSpace(getRootWorkSpace());
    }

    /**
     * Remove the selected workspace
     *
     * @param workSpace
     * @return true if current workspace is also removed
     */
    public boolean removeAllWorkSpace(List<WorkSpace> workSpace) {
        getWorkSpaces().removeAll(workSpace);
        if (!getWorkSpaces().contains(getRootWorkSpace())) {
            getWorkSpaces().add(getRootWorkSpace());
        }
        boolean currentWorkSpaceDeleted = !getWorkSpaces().contains(getCurrentWorkSpace());
        if (currentWorkSpaceDeleted) {
            setCurrentWorkSpace((WorkSpace) null);
            setNextWorkSpace(getRootWorkSpace());
        }
        return currentWorkSpaceDeleted;
    }

    public Optional<WorkSpace> findWorkSpace(String workSpaceId) {
        return getWorkSpaces().stream().filter(ws -> ws.getId().equals(workSpaceId)).findAny();
    }

    public Optional<WorkSpace> findWorkSpaceByName(String workSpaceName) {
        return getWorkSpaces().stream().filter(ws -> ws.getName().equals(workSpaceName)).findAny();
    }

    /**
     * @return the jaxbSupport
     */
    public Boolean getJaxbSupport() {
        if (jaxbSupport == null) {
            jaxbSupport = false;
        }
        return jaxbSupport;
    }

    /**
     * @param jaxbSupport the jaxbSupport to set
     */
    public void setJaxbSupport(Boolean jaxbSupport) {
        this.jaxbSupport = jaxbSupport;
    }

    /**
     * @return the jsonbSupport
     */
    public Boolean isJsonbPackageInfoExist() {
        return //jsonbPropertyNamingStrategy!=null
                //jsonbPropertyOrderStrategy!=null
                (jsonbNillable != null && jsonbNillable != false)
                || (jsonbDateFormat != null && !jsonbDateFormat.isEmpty())
                || (jsonbNumberFormat != null && !jsonbNumberFormat.isEmpty())
                || (jsonbVisibility != null && isNotBlank(jsonbVisibility.getName()));
    }

    /**
     * @return the jsonbPropertyNamingStrategy
     */
    public PropertyNamingStrategy getJsonbPropertyNamingStrategy() {
        return jsonbPropertyNamingStrategy;
    }

    /**
     * @param jsonbPropertyNamingStrategy the jsonbPropertyNamingStrategy to set
     */
    public void setJsonbPropertyNamingStrategy(PropertyNamingStrategy jsonbPropertyNamingStrategy) {
        this.jsonbPropertyNamingStrategy = jsonbPropertyNamingStrategy;
    }

    /**
     * @return the jsonbNillable
     */
    public Boolean getJsonbNillable() {
        if (jsonbNillable == null) {
            return false;
        }
        return jsonbNillable;
    }

    /**
     * @param jsonbNillable the jsonbNillable to set
     */
    public void setJsonbNillable(Boolean jsonbNillable) {
        this.jsonbNillable = jsonbNillable;
    }

    /**
     * @return the jsonbDateFormat
     */
    public JsonbDateFormat getJsonbDateFormat() {
        if (jsonbDateFormat == null) {
            jsonbDateFormat = new JsonbDateFormat();
        }
        return jsonbDateFormat;
    }

    /**
     * @param jsonbDateFormat the jsonbDateFormat to set
     */
    public void setJsonbDateFormat(JsonbDateFormat jsonbDateFormat) {
        this.jsonbDateFormat = jsonbDateFormat;
    }

    /**
     * @return the jsonbNumberFormat
     */
    public JsonbNumberFormat getJsonbNumberFormat() {
        if (jsonbNumberFormat == null) {
            jsonbNumberFormat = new JsonbNumberFormat();
        }
        return jsonbNumberFormat;
    }

    /**
     * @param jsonbNumberFormat the jsonbNumberFormat to set
     */
    public void setJsonbNumberFormat(JsonbNumberFormat jsonbNumberFormat) {
        this.jsonbNumberFormat = jsonbNumberFormat;
    }

    /**
     * @return the jsonbVisibility
     */
    @Override
    public ReferenceClass getJsonbVisibility() {
        return jsonbVisibility;
    }

    /**
     * @param jsonbVisibility the jsonbVisibility to set
     */
    @Override
    public void setJsonbVisibility(ReferenceClass jsonbVisibility) {
        this.jsonbVisibility = jsonbVisibility;
    }

    /**
     * @return the jsonbPropertyOrderStrategy
     */
    public PropertyOrderStrategy getJsonbPropertyOrderStrategy() {
        return jsonbPropertyOrderStrategy;
    }

    /**
     * @param jsonbPropertyOrderStrategy the jsonbPropertyOrderStrategy to set
     */
    public void setJsonbPropertyOrderStrategy(PropertyOrderStrategy jsonbPropertyOrderStrategy) {
        this.jsonbPropertyOrderStrategy = jsonbPropertyOrderStrategy;
    }

    /**
     * @return the jbTheme
     */
    public String getJBTheme() {
        return jbTheme;
    }

    /**
     * @param jbTheme the jbTheme to set
     */
    public void setJBTheme(String jbTheme) {
        this.jbTheme = jbTheme;
    }

}
